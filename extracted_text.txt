MULTITHREADINGCSE13SProf. Darrell Long6/2/21© 2021 EUGENE CHOU AND DARRELL LONG1 PROCESSES & THREADSWhat’s a process?­Code, data, and stack­Usually has its own address space­Program state­CPU registers­Program counter (current location in the code)­Stack pointerOnly one processcan run on a single CPU core at any given time.­Multi-core CPUs can support multiple processes and threads.A process contains one or more threads.­Threads within a process run concurrently.­Threads share memory with each other.­They live in the same address space!Process Items•Address space•Open files•Child processes•Signals & handlers•Accounting info•Global variablesThread Items•Program counter•Register values•Stack•Stack pointer•Local variables 6/2/21© 2021 EUGENE CHOU AND DARRELL LONG2 ADDRESS SPACEPrograms execute code.­Each instruction has an address.Programs access data.­Each byte of data also has an address.We would like to think that our program is the only program executing on the computer.­Which prompts the need for a level of abstraction by the OS.An address space is the region of a computer’s memory where a program executes.­Ideally, it is protected from other programs accessing it.textdatabssheapstack0x000FFFFF0x00000000process 6/2/21© 2021 EUGENE CHOU AND DARRELL LONG3 SINGLE VSMULTI-THREADED ADDRESS SPACES Threads do not replace processes, they enhance them.Single-threadedprocesstextdatabssheapstackMulti-threadedprocesstextdatabssheapstackstackthread 2thread 1 6/2/21© 2021 EUGENE CHOU AND DARRELL LONG4 WHY USE THREADS?Faster to create or destroy than processes.­No separate address space.Allow a single application to do many things at once (like a web server).­Can keep working during IO wait.­Each threads gets to issue its own IOs.­More IOs can be outstanding/pending.Context switching:­Expensive between processes.­Less expensive between threads.Sharing memory:­Processes don’t inherently share memory (each process has its own address space).­Need to use inter-process communication (IPC) to manage shared data.­Threads share memory, making it easier to share data.6/2/21© 2021 EUGENE CHOU AND DARRELL LONG5 BASIC POSIXTHREAD APIThread callDescriptionpthread_create()Create a new thread.pthread_join()Wait for a thread to complete.The POSIX thread library for C is a standard API for multithreading.­Included under <pthread.h>.For basic multithreading, we will only really need two of the functions:1.pthread_create()2.pthread_join()More into the details and ideas of these functions in a bit.6/2/21© 2021 EUGENE CHOU AND DARRELL LONG6 CREATING A THREADA process is started with one thread of execution: the main thread.The main thread can create threads, and those threads may create other threads as well.­Threads are siblings, no sense of hierarchy between them.­The main thread, though, should end last.­If it ends, the process ends.When a thread is created, it gets:­A thread ID­A program counter­A stack and a stack pointer­Register values­Some priority­Affects the thread execution order.­The higher the priority, the earlier it gets scheduled.main threadthread 1thread 2thread 4thread 3timecreatescreatescreatescreates 6/2/21© 2021 EUGENE CHOU AND DARRELL LONG7 CONTEXT SWITCHINGHalting (or pausing) the execution of a certain thread by the OS for some reason in order to execute some other thread.Involves saving the state of the process or thread into a private memory region, so that the state can be reloaded and execution resumed later on.Analogy:­You are reading a book, and a friend comes along and requests to read the book as well.­You save your position in the book, and hand off the book to your friend.­You can also request the book back from your friend.­The friend will save their position in the book, and hand it back to you.­You then continue reading from the position that you saved from before.The more that needs to be saved, the more expensive the switch.Excessive context switching should be avoided.6/2/21© 2021 EUGENE CHOU AND DARRELL LONG8 GREETINGS, I’M A THREADHere we’ll define a simple program that spawns threads and makes each one print out a message.­We create 3 threads.­Each will print out their thread ID, the language assigned to them, and a message in that language.Upon creation, each thread is given a function, or a start routine, to execute.­This function is allowed at most one argument.If you need to pass multiple arguments to the start routine, you must first define a struct that contains those arguments.­In this case, we bundle the language and message into one argument struct.But what does the loop at the end do?­What might happen if the main thread finishes execution but the other threads haven’t?­We solve this by joining threads. 6/2/21© 2021 EUGENE CHOU AND DARRELL LONG9 JOINING A THREADTo join a thread means waiting for it to finish.Basic idea:­Let threads perform some job in parallel.­Wait for all threads tasked with the job to finish.­Once all threads finish execution, the job is completed.­This is where joining comes in!­Weird things can happen if you continue your program without verifying that all threads are done.There are cases in which you do not want to join threads.­You want the main thread to continue execution while the other threads do their assigned tasks.­Commonly seen in web servers.thread creation thread join6/2/21© 2021 EUGENE CHOU AND DARRELL LONG10 FIRST TRY AT MULTITHREADINGWe’ll write a simple multithreaded program.­Each process starts out with a main thread.­This main thread will then spawn 4 additional threads.­Each of these threads is tasked with incrementing a global counter 10000 times.­The threads are joined, and the final counter value is printed.We expect the output of this program to be 40000.­We run the program 10 times in succession, but the output is never correct.­Why? Because of race conditions. 6/2/21© 2021 EUGENE CHOU AND DARRELL LONG11 RACE CONDITIONSThreads share memory.­Different threads may read/write the same memory.­Thus, threads share resources.Problem: no guarantee that read followed by write is atomic.­Which means the ordering of events matters!­Also results in erroneous results.Example on right shows the problem with the first attempt at multithreading.­Why some increments of the counter didn’t seem to take effect.Thread 1Thread 2Memoryget 𝑥𝑥=5get 𝑥𝑥=5𝑥+=1𝑥+=1𝑥=6Incremented once, not twice!6/2/21© 2021 EUGENE CHOU AND DARRELL LONG12 CRITICAL REGIONSUse critical regions to provide mutual exclusionto help fix race conditions.Four conditions must hold to provide mutual exclusion:1.No two processes may simultaneously be in critical region.2.No assumptions may be made about speed.3.No process running outside its critical region may block another process.4.A process may not wait forever to enter the critical region.A process in this sense doesn’t need to be specifically an OS process.­Could be a thread, or a database connection.Thread 1Thread 2Memoryget 𝑥𝑥=5get 𝑥𝑥=6𝑥+=1 𝑥=7Thread 2 blocked from critical region! 𝑥+=1Thread 1 blocked from critical region! 6/2/21© 2021 EUGENE CHOU AND DARRELL LONG13 LOCKING FOR MUTUAL EXCLUSIONThe locking out of threads from critical regions is done using a mutex.­With POSIX threads, this is type pthread_mutex_t.Two main operations:1.pthread_mutex_lock()2.pthread_mutex_unlock()Idea:­Have a mutex for a critical region.­Before entering the critical region, a thread must lock the mutex first.­If the mutex has already been locked, the thread is blocked until it has been unlocked.­The thread unlocks the mutex after leaving the critical region. 6/2/21© 2021 EUGENE CHOU AND DARRELL LONG14 SECOND TRY AT MULTITHREADING We go back and add locks around the incrementing loop.­That’s the critical region.­Now, only one thread and increment the counter at a time.Running this revised code yields the correct result.­4 threads incrementing a counter 10000 times each should yield 40000.6/2/21© 2021 EUGENE CHOU AND DARRELL LONG15 DEADLOCKSFormal definition: “A set of processes is deadlockedif each process in the set is waiting for an event that only another process in the set can cause”.Basically, a cyclic dependency on some resource.­Process A needs 𝑥from process B in order to run.­Process B needs 𝑦from process A in order to run.­Neither process is willing to give up granted resources.Process AProcess BResource 𝑦Resource 𝑥ownsneeded byneeded byowns 6/2/21© 2021 EUGENE CHOU AND DARRELL LONG16 RESOURCESResource: something a process uses (usually limited).Examples of computer resources:­Printers­Semaphores/locks­Memory (with threads, this is usually a sharedvariable)­Tables (in a database)Processes need access to resources in reasonable order.Two types of resources:­Preemptable resources: can be taken away from a process with no ill effects.­Non-preemptable resources: causes ill effects if taken away from a process.6/2/21© 2021 EUGENE CHOU AND DARRELL LONG17 USING RESOURCESTo use a resource, a process must:1.Request the resource2.Do something with the resource3.Release the resourceCan’t use the resource if the initial request is denied.­The requesting process has some options:­Block and wait for the resource.­Continue (if possible) without it, potentially using an alternate resource.­Fail with an error code.­Some of these options may be able to prevent deadlocks from occurring.6/2/21© 2021 EUGENE CHOU AND DARRELL LONG18 CONDITIONS FOR DEADLOCKThere are 4 conditions necessary for deadlock:1.Mutual exclusion­Each resource is assigned to at most one process.2.Hold & wait­A process holding resources can request more resources.3.No preemption­Resources granted previous cannot be forcibly taken away.4.Circular wait­There must be a circular chain of 2 or more processes where each is waiting for a resource held by the next member of the chain. 6/2/21© 2021 EUGENE CHOU AND DARRELL LONG19 RESOURCE ALLOCATION GRAPHSResource allocation can be modeled using directedgraphs.Example 1:­Resource X is assigned to process A.­Process A is requesting/waiting for resource Y.Example 2:­Process A holds X and is waiting for Y.­Process B holds Y and is waiting for X.­A and B are in deadlock!AXY BYXA21 6/2/21© 2021 EUGENE CHOU AND DARRELL LONG20 GETTING INTO DEADLOCKAXBYCZAXBYCZAXBYCZAXBYCZAXBYCZAXBYCZA acquires XB acquires YC acquires ZA acquires YB acquires ZC acquires X: DEADLOCKProcess A:­Acquire X­Acquire Y­Release X­Release YProcess B:­Acquire Y­Acquire Z­Release Y­Release ZProcess C:­Acquire Z­Acquire X­Release Z­Release X6/2/21© 2021 EUGENE CHOU AND DARRELL LONG21 THE OSTRICH ALGORITHMSimply pretend that there’s no problem.This is reasonable if:­Deadlocks occur very rarely.­Preventing deadlocks is costly.Unix and Windows take this approach.­Resources (memory, CPU, disk space) are plentiful.­Deadlocks over such resources rarely occur.­If a deadlock does occur, it is typically handled by rebooting.This is a trade off between convenienceand correctness. 6/2/21© 2021 EUGENE CHOU AND DARRELL LONG22 AVOIDING DEADLOCKMany situations may result in deadlock, but they do not necessarily have to.­In previous example, A could have released X before C requested it, avoiding the deadlock.­Can we always get out of it this way?We want to either:­Detect deadlocks and reverse them, or­Stop deadlocks from occurring in the first place.AXBYCZAXBYCZAXBYCZAXBYCZAXBYCZAXBYCZA acquires XB acquires YC acquires ZA acquires YA releases XB acquire ZC acquires X6/2/21© 2021 EUGENE CHOU AND DARRELL LONG23 DEADLOCK DETECTION WITH GRAPHSProcess holdings and requests in resource allocation graph.­If graph contains a cycle, then there exists a deadlock.Algorithm:­DFS at each node.­Mark arcs as they’re traversed.­Build set of visited nodes.­If a node to be visited is already in the set of visited nodes, then a cycle has been found.// Deadlock detection pseudocode.for node n in graph G {visited = empty setunmark all arcs in Gtraverse(n, visited, G) }functraverse(n, visited, G) {if n in visited {report deadlock}add n to visitedfor unmarked arc n to m in G {mark the arctraverse(m, visited, g)}remove n from visited}6/2/21© 2021 EUGENE CHOU AND DARRELL LONG24 RECOVERING FROM DEADLOCKRecovery through preemption­Take a resource from some other process.­This depends on the nature of the resource and process.Recovery through rollback­Checkpoint a process periodically.­Use saved state to restart the process if it’s in deadlock.­This may be a problem if the process affects lots of “external” things.Recovery through killing processes­Crude but simple: kill one of the processes in the deadlock cycle.­Allows other processes to get their resources.­Try to choose a process that can be rerun from the start.­Pick one that hasn’t run too far already.6/2/21© 2021 EUGENE CHOU AND DARRELL LONG25 PREVENTING DEADLOCKIt is sometimes possible to completely prevent deadlock.­Simply ensure that at least one of the 4 necessary conditions for deadlock never occurs.Try to attack:1.Mutual exclusion2.Hold & wait3.No preemption4.Circular wait 6/2/21© 2021 EUGENE CHOU AND DARRELL LONG26 ATTACKING MUTUAL EXCLUSIONSome devices (such as printers) can be spooled.­Only the printer daemon uses printer resource.­This eliminates deadlock for the printer.Spooling: queueing tasks together, in which a dedicated program, the spooler, dequeues as needed.­The term spooling was probably used due to magnetic tape wound onto a spool.Principle:­Avoid assigning the resource when it isn’t absolutely necessary.­As few processes as possible can actually claim the resource.Spooling cannot be used for all devices… 6/2/21© 2021 EUGENE CHOU AND DARRELL LONG27 ATTACKING “HOLD & WAIT”Require processes to request resources before starting.­A process never has to wait for what it needs.This can present issues:­A problem may not know what resources it needs before it starts.­This also ties up resources other processes could be using.­Processes will tend to be conservative and request resources they might need.Variation: a process must give up all resources before making a new request.­Process is then granted all prior resources as well as the new ones.­Problem: what if the sources are claimed by another process in the meantime –how can the process save its state?6/2/21© 2021 EUGENE CHOU AND DARRELL LONG28 ATTACKING “NO PREEMPTION”Attack ”no preemption” by allowing preemption.Typically not a viable option.Consider a process given a printer:­Halfway through the job, take away the printer.Could work for some resources.­Forcibly take away memory pages, suspending the process.­Might be possible for process to resume with no ill effects. 6/2/21© 2021 EUGENE CHOU AND DARRELL LONG29 ATTACKING “CIRCULAR WAIT”Assign an order to resources.­Acquire the resources in numerical order.­No need to acquire all of them at once.Circular wait is prevented.­A process holding resource 𝑦can’t wait for resource 𝑥if 𝑥<𝑦.­No way to complete a cycle.­Place processes above highest resource they hold and below any they’re requesting.­All arrows in the resource allocation graph will then point upwards.C1ABD23 6/2/21© 2021 EUGENE CHOU AND DARRELL LONG30 DEADLOCK PREVENTION: SUMMARYConditionPrevented byMutual exclusionSpool if possible.Hold & waitRequest all resources before starting.No preemptionTake resources away if there isn’t a complete set.Circular waitOrder resources numerically.6/2/21© 2021 EUGENE CHOU AND DARRELL LONG31 STARVATIONAssume the following algorithm to allocate a resource:­Give the resource to the shortest job first.Works great for multiple short jobs in a system.­May cause long jobs to be postponed indefinitely.Solution:­Use a first-come, first-serve policy instead.Starvation can lead to deadlock.­Process starved for resources can already be holding resources.­If those resource aren’t used and released in a timely manner, the shortage could lead to deadlock.6/2/21© 2021 EUGENE CHOU AND DARRELL LONG32 Prof. Darrell Long 6/2/21 © 2021 EUGENE CHOU AND DARRELL LONG ] PROCESSES & THREADS What’s a process? Code, data, and stack Usually has its own address space Program state CPU registers Thread Items Program counter (current location in the code) Stack pointer Program counter Register values Only one process can run on a single CPU Sica core at any given time. tac Multi-core CPUs can support multiple processes Stack pointer and threads. Local variables A process contains one or more threads. Threads within a process run concurrently. Threads share memory with each other. They live in the same address space! 6/2/21 © 2021 EUGENE CHOU AND DARRELL LONG 2 ADDRESS SPACE 0x00000000 Programs execute code. * Each instruction has an address. Programs access data. » Each byte of data also has an address. We would like to think that our program is the only Process program executing on the computer. » Which prompts the need for a level of abstraction by the OS. An address space is the region of a computer’s memory where a program executes. te wo FFFFF * Ideally, it is protected from other programs accessing it. 0x000 6/2/21 © 2021 EUGENE CHOU AND DARRELL LONG 3 SINGLE vs MULTI-THREADED ADDRESS SPACES process process thread 1 thread 2 Single-threaded Multi-threaded Threads do not replace processes, they enhance them. 6/2/21 © 2021 EUGENE CHOU AND DARRELL LONG WHY USE THREADS? Faster to create or destroy than processes. " No separate address space. Allow a single application to do many things at once (like a web server). * Can keep working during IO wait. * Each threads gets to issue its own IOs. * More IOs can be outstanding/pending. Context switching: » Expensive between processes. » Less expensive between threads. Sharing memory: " Processes don’t inherently share memory (each process has its own address space). » Need to use inter-process communication (IPC) to manage shared data. " Threads share memory, making it easier to share data. 6/2/21 © 2021 EUGENE CHOU AND DARRELL LONG 5 BASIC POSIX THREAD API The POSIX thread library for C is a standard API for multithreading. * Included under <pthread.h>. Thread call Description For basic multithreading, we will only really need two of the pthread_create() Create a new thread. functions: 1. pthread_create() 2. pthread join() pthread_join() Wait for a thread to complete. More into the details and ideas of these functions in a bit. 6/2/21 © 2021 EUGENE CHOU AND DARRELL LONG 6 CREATING A THREAD A process is started with one thread of execution: the main thread. The main thread can create threads, and those threads may create other threads as well. * Threads are siblings, no sense of hierarchy between them. * The main thread, though, should end last. * If it ends, the process ends. When a thread is created, it gets: » A thread ID * A program counter * A stack and a stack pointer * Register values » Some priority » Affects the thread execution order. * The higher the priority, the earlier it gets scheduled. 6/2/21 main thread creates creates time thread 1 thread 2 creates creates thread 3 thread 4 © 2021 EUGENE CHOU AND DARRELL LONG CONTEXT SWITCHING Halting (or pausing) the execution of a certain thread by the OS for some reason in order to execute some other thread. Involves saving the state of the process or thread into a private memory region, so that the state can be reloaded and execution resumed later on. Analogy: » You are reading a book, and a friend comes along and requests to read the book as well. » You save your position in the book, and hand off the book to your friend. * You can also request the book back from your friend. * The friend will save their position in the book, and hand it back to you. * You then continue reading from the position that you saved from before. The more that needs to be saved, the more expensive the switch. Excessive context switching should be avoided. 6/2/21 © 2021 EUGENE CHOU AND DARRELL LONG GREETINGS, I'M A THREAD #include <inttypes.h> #include <pthread.h> #include <stdio.h> Here we'll define a simple program that spawns threads and makes each one print out a message. We create 3 threads. #define NUM_THREADS 3 def t Args { Each will print out their thread ID, the language assigned to them, *language; and a message in that language. a ee 5 Args; . : : . id xs (A da Upon creation, each thread is given a function, or a Gd © OF ° pthre readid_np(pthread f(), &tid); start routine, to execute. printf("I'm thread %" PRIu64 I speak \n", tid, a—language, a—>message); This function is allowed at most one argument. return NULL; Hf nt main( df If you need to pass multiple arguments to the start re ee tL om mninima WEN routine, you must first define a struct that contains those a nglish", "Hello" }; arguments. pt e(&threads[@], NULL, id *)speak, &a); In this case, we bundle the language and message into one Bers b = 8 GaoreiP, Cees? De argument struct. pthread_create(Sthreads[1], NULL, *)speak, &b); Args c = { "Italian", "Ciao" }; But what does the loop at the end do? pthread_create(&threads[2], NULL, (void *)speak, &¢); What might happen if the main thread finishes execution but the for (int i = 0; i < NUM_THREADS; i += 1) { other threads haven't? pthread_join(threads[i], NULL); } We solve this by joining threads. return 0; 6/2/21 © 2021 EUGENE CHOU AND DARRELL LONG 9 JOINING A THREAD To join a thread means waiting for it to finish. Basic idea: * Let threads perform some job in parallel. * Wait for all threads tasked with the job to finish. * Once all threads finish execution, the job is completed. * This is where joining comes in! * Weird things can happen if you continue your program without verifying that all threads are done. There are cases in which you do not want to join threads. » You want the main thread to continue execution while the other threads do their assigned tasks. » Commonly seen in web servers. 6/2/21 thread creation thread join © 2021 EUGENE CHOU AND DARRELL LONG 10 FIRST TRY AT MULTITHREADING We'll write a simple #include <stdio.h> multithreaded program. #include <pthread.h> $ for 1 in {0 vies 10} Each process starts out with a main define NUM THREADS 4 for> do thread. for> ./thread_unsafe t counter = Q; This main thread will then spawn 4 a for> done additional threads. Aer i, eerie es counter 29157 Each of these threads is tasked , SUT fet Et counter 18830 with incrementing a global counter Teun (TULLg counter 20291 10000 times. i ee counter The threads are joined, and the t main(void) { counter 16679 pthread_t threads[NUM_THREADS]; for (int i = 0; i < NUM_THREADS; i += 1) { pthread_create(Sthreads[i], NULL, (void *)increase, NULL); final counter value is printed. counter 19092 counter 22780 counter 23898 We expect the output of this } program to be A0OOO. for (int i = 0; i < NUM_THREADS; i += 1) pthread_join(threads[i], NULL); We run the program 10 times in } counter 25092 succession, but the output is never printf("counter \n", counter); counter 18460 correct. return 0; counter 19462 Why? Because of race conditions. 6/2/21 © 2021 EUGENE CHOU AND DARRELL LONG i RACE CONDITIONS Thread 1 Memory Thread 2 Threads share memory. * Different threads may read/write the same memory. Thus, threads share resources. Problem: no guarantee that read followed by write is atomic. = Which means the ordering of events matters! = Also results in erroneous results. Example on right shows the problem with the first attempt at multithreading. » Why some increments of the counter didn’t seem to r= 6 ; Incremented once, not twice! take effect. 6/2/21 © 2021 EUGENE CHOU AND DARRELL LONG 12 CRITICAL REGIONS Thread 1 Memory Thread 2 Use critical regions to provide mutual exclusion to help fix race conditions. Thread 2 blocked from critical region! Four conditions must hold to provide mutual exclusion: |. No two processes may simultaneously be in critical region. 2. No assumptions may be made about speed. 3. No process running outside its critical region may Thread 1 blocked block another process. from critical region! 4. A process may not wait forever to enter the critical region. A process in this sense doesn’t need to be specifically an OS process. * Could be a thread, or a database connection. 6/2/21 © 2021 EUGENE CHOU AND DARRELL LONG 13 LOCKING FOR MUTUAL EXCLUSION The locking out of threads from critical regions is done using a mutex. " With POSIX threads, this is type pthread_mutex_ t. Two main operations: i. pthread_mutex_ lock() 2. pthread_mutex_unlock() Idea: * Have a mutex for a critical region. "Before entering the critical region, a thread must lock the mutex first. If the mutex has already been locked, the thread is blocked until it has been unlocked. * The thread unlocks the mutex after leaving the critical region. 6/2/21 © 2021 EUGENE CHOU AND DARRELL LONG 14 SECOND TRY AT MULTITHREADING $ for iin {0..10} for> do for> ./thread_safe for> done counter = 40000 #include <stdio.h> We go back and add #include <pthread.h> locks around the define NUM_THREADS 4 e e t counter = 0; incrementing loop. id *increase() { static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER; That’s the critical region. Now, only one thread and for nts 6; «00m, a) counter = 40000 increment the counter at a » road mutex umtock¢stock); counter = 40000 time. ceturn NULL; counter = 40000 counter 40000 Running this revised code STEAL ohne tae ROTEL counter 40000 yields the correct result. fo pthread ereate(sthreads[il, NULL, (void *)increase, WULL): counter = 40000 4 threads incrementing a ay AA ee counter 40000 counter 10000 times each STEEN; CUE counter 40000 counter 40000 counter 40000 should yield 40000. printf("counter = %d\n", counter); return 0; 6/2/21 © 2021 EUGENE CHOU AND DARRELL LONG 15 DEADLOCKS Formal definition: “A set of processes is deadlocked if each process in the set is waiting for an event that only another process in the set can cause”. Basically, a cyclic dependency on some resource. = Process A needs x from process B in order to run. " Process B needs y from process A in order to run. * Neither process is willing to give up granted resources. 6/2/21 Process A owns Resource y needed by needed by Resource X owns Process B © 2021 EUGENE CHOU AND DARRELL LONG 16 RESOURCES Resource: something a process uses (usually limited). Examples of computer resources: * Printers » Semaphores/locks » Memory (with threads, this is usually a shared variable) * Tables (in a database) Processes need access to resources in reasonable order. Two types of resources: » Preemptable resources: can be taken away from a process with no ill effects. " Non-preemptable resources: causes ill effects if taken away from a process. 6/2/21 © 2021 EUGENE CHOU AND DARRELL LONG USING RESOURCES To use a resource, A process must: |. Request the resource 2. Do something with the resource 3. Release the resource Can’t use the resource if the initial request is denied. * The requesting process has some options: * Block and wait for the resource. * Continue (if possible) without it, potentially using an alternate resource. * Fail with an error code. " Some of these options may be able to prevent deadlocks from occurring. 6/2/21 © 2021 EUGENE CHOU AND DARRELL LONG 18 CONDITIONS FOR DEADLOCK There are 4 conditions necessary for deadlock: 1. Mutual exclusion . Each resource is assigned to at most one process. 2. Hold & wait A process holding resources can request more resources. 3. No preemption . Resources granted previous cannot be forcibly taken away. 4. Circular wait . There must be a circular chain of 2 or more processes where each is waiting for a resource held by the next member of the chain. 6/2/21 © 2021 EUGENE CHOU AND DARRELL LONG 19 RESOURCE ALLOCATION GRAPHS Resource allocation can be modeled using Lo | directed graphs. Y X Example 1: " Resource X is assigned to process A. * Process A is requesting /waiting for resource Y. Example 2: » Process A holds X and is waiting for Y. » Process B holds Y and is waiting for X. = A and B are in deadlock! 6/2/21 © 2021 EUGENE CHOU AND DARRELL LONG 20 GETTING INTO DEADLOCK ‘= WOOO OOO OOO Acquire X Acquire Y Release X = BPH BN Oo Process B: . . . Acquire Y A acquires X B acquires Y C acquires Z Acquire Z Release Y Release Z Process C: Acquire Z Acquire X Release Z Release X A acquires Y B acquires Z C acquires X: DEADLOCK 6/2/21 © 2021 EUGENE CHOU AND DARRELL LONG 21 THE OSTRICH ALGORITHM Simply pretend that there’s no problem. This is reasonable if: * Deadlocks occur very rarely. " Preventing deadlocks is costly. Unix and Windows take this approach. » Resources (memory, CPU, disk space) are plentiful. * Deadlocks over such resources rarely occur. * If a deadlock does occur, it is typically handled by rebooting. This is a trade off between convenience and correctness. 6/2/21 © 2021 EUGENE CHOU AND DARRELL LONG 22 AVOIDING DEADLOCK Many situations may result in deadlock, but they do not necessarily have to. =v" TH Boe We A could have released X before C requested it, avoiding the deadlock. Can we always get out of it this way? A acquires X B acquires Y C acquires Z We want to either: Detect deadlocks and reverse them, or Stop deadlocks from . : occurring in the first A acquires Y A releases X C acquires X place. B acquire Z 6/2/21 © 2021 EUGENE CHOU AND DARRELL LONG 23 DEADLOCK DETECTION WITH GRAPHS // Deadlock detection pseudocode. Process holdings and requests in resource for node n in graph G { allocation graph. visited = empty set . . unmark all arcs in G * If graph contains a cycle, then there exists a deadlock. } traverse(n, visited, G) Algorithm: func traverse(n, visited, G) { if n in visited { DFS at each node. report deadlock » Mark ares as they’re traversed. } add n to visited for unmarked arc n to m in G { " If a node to be visited is already in the set of mark the arc visited nodes, then a cycle has been found. ; traverse(m, visited, 9) remove n from visited = Build set of visited nodes. 6/2/21 © 2021 EUGENE CHOU AND DARRELL LONG 24 RECOVERING FROM DEADLOCK Recovery through preemption " Take a resource from some other process. " This depends on the nature of the resource and process. Recovery through rollback * Checkpoint a process periodically. » Use saved state to restart the process if it’s in deadlock. " This may be a problem if the process affects lots of “external” things. Recovery through killing processes * Crude but simple: kill one of the processes in the deadlock cycle. * Allows other processes to get their resources. " Try to choose a process that can be rerun from the start. * Pick one that hasn't run too far already. 6/2/21 © 2021 EUGENE CHOU AND DARRELL LONG 25 PREVENTING DEADLOCK It is sometimes possible to completely prevent deadlock. * Simply ensure that at least one of the 4 necessary conditions for deadlock never occurs. Try to attack: |. Mutual exclusion 2. Hold & wait 3. No preemption 4 Circular wait 6/2/21 © 2021 EUGENE CHOU AND DARRELL LONG 26 ATTACKING MUTUAL EXCLUSION Some devices (such as printers) can be spooled. " Only the printer daemon uses printer resource. * This eliminates deadlock for the printer. Spooling: queueing tasks together, in which a dedicated program, the spooler, dequeues as needed. " The term spooling was probably used due to magnetic tape wound onto a spool. Principle: » Avoid assigning the resource when it isn’t absolutely necessary. » As few processes as possible can actually claim the resource. Spooling cannot be used for all devices... 6/2/21 © 2021 EUGENE CHOU AND DARRELL LONG ATTACKING “HOLD & WAIT” Require processes to request resources before starting. " A process never has to wait for what it needs. This can present issues: * A problem may not know what resources it needs before it starts. * This also ties up resources other processes could be using. » Processes will tend to be conservative and request resources they might need. Variation: a process must give up all resources before making a new request. » Process is then granted all prior resources as well as the new ones. * Problem: what if the sources are claimed by another process in the meantime — how can the process save its state? 6/2/21 © 2021 EUGENE CHOU AND DARRELL LONG ATTACKING “NO PREEMPTION” Attack ”no preemption” by allowing preemption. Typically not a viable option. Consider a process given a printer: " Halfway through the job, take away the printer. Could work for some resources. * Forcibly take away memory pages, suspending the process. » Might be possible for process to resume with no ill effects. 6/2/21 © 2021 EUGENE CHOU AND DARRELL LONG ATTACKING “CIRCULAR WAIT” Assign an order to resources. » Acquire the resources in numerical order. = No need to acquire all of them at once. Circular wait is prevented. " A process holding resource y can’t wait for resource X if X < y. = No way to complete a cycle. = Place processes above highest resource they hold and below any they’re requesting. * All arrows in the resource allocation graph will then point upwards. 6/2/21 © 2021 EUGENE CHOU AND DARRELL LONG 30 DEADLOCK PREVENTION: SUMMARY Prevented by Mutual exclusion Spool if possible. Hold & wait Request all resources before starting. No preemption Take resources away if there isn’t a complete set. Circular wait Order resources numerically. 6/2/21 © 2021 EUGENE CHOU AND DARRELL LONG 31 STARVATION Assume the following algorithm to allocate a resource: " Give the resource to the shortest job first. Works great for multiple short jobs in a system. » May cause long jobs to be postponed indefinitely. Solution: " Use a first-come, first-serve policy instead. Starvation can lead to deadlock. " Process starved for resources can already be holding resources. * If those resource aren’t used and released in a timely manner, the shortage could lead to deadlock. 6/2/21 © 2021 EUGENE CHOU AND DARRELL LONG